name: Deploy to VPSSss

on:
  push:
    branches:
      - deploy # Trigger on push to the 'main' branch

jobs:
  deploy:
    runs-on: ubuntu-latest # Use the latest Ubuntu runner provided by GitHub Actions

    steps:
      - name: Checkout code
        uses: actions/checkout@v4 # Action to check out your repository code

      - name: Add SSH Host Key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts # Ensure correct permissions
          
      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0 # Securely manages SSH keys for deployment
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}


      # - name: Deploy with Docker Compose
      #   env:
      #     # Pass secrets as environment variables for the SSH command
      #     # These are used to dynamically create the .env files on the VPS
      #     APP_ENV_CONTENT: ${{ secrets.APP_ENV_CONTENT }}
      #     DB_ENV_CONTENT: ${{ secrets.DB_ENV_CONTENT }}
      #   run: |
      #     # Use SSH to connect to the VPS and execute commands
      #     # The -T flag disables pseudo-terminal allocation for non-interactive commands
      #     # The 'set -e' ensures that the script exits immediately if any command fails
      #     ssh -T ${{ secrets.VPS_USERNAME }}@${{ secrets.VPS_HOST }} << 'EOF'
      #       set -e

      #       # Navigate to your project directory on the VPS
      #       cd ${{ secrets.PROJECT_DIR }}

      #       # Pull the latest code from your GitHub repository
      #       echo "Pulling latest code..."
      #       git pull

      #       # Create/Update .env files on the VPS using the secrets
      #       # The 'EOF' marker needs to be alone on a line to signify the end of the here-document
      #       echo "Creating/Updating .env files on VPS..."
      #       echo "$APP_ENV_CONTENT" > .env
      #       echo "$DB_ENV_CONTENT" > .env.db

      #       # Stop and remove old containers, but preserve volumes (including database data)
      #       echo "Stopping existing Docker Compose services..."
      #       docker compose down

      #       # Build new images (if Dockerfile changed) and start services in detached mode
      #       echo "Starting new Docker Compose services..."
      #       docker compose up -d --build

      #       # Optional: Prune old Docker images to save disk space
      #       # This removes dangling images (not associated with any container)
      #       echo "Cleaning up old Docker images..."
      #       docker image prune -f

      #       echo "Deployment successful!"
      #     EOF